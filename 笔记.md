## 测试驱动开发

​	测试驱动开发（TDD）以**测试作为开发过程的中心**，它要求编写任何产品代码之前，**首先编写用于定义产品代码行为的测试**，编写代码又以**使测试通过为目标**。代码整洁可用也正是TDD所追求的目标。 使用TDD进行开发，开发过程主要在这三个阶段（**不可运行/可运行/重构**）：

- 不可运行-写一个不能工作的测试程序，甚至不能编译
- 可运行-尽快让这个测试程序可以工作，可以引入不合理的方法
- 重构-消除重复设计，优化设计结构

### 例1: Money Example

​	在进行TDD进行开发的时候，可以建立一个计划清单，以提醒我们需要做哪些事情，它将使我们始终保持注意力集中，同时也可以告诉我们什么时候可以完工：粗体可以表示**正在进行**，~~完成项~~可以添加删除线。**可以随时将一些想到的问题记录下来**，然后继续进行这个循环的TDD。
​	计划清单的先后顺序应该是：**先从被依赖的测试开始写**。

#### 依赖关系和重复设计

​	测试程序与代码所存在的问题不在于重复设计，而在于代码与测试程序之间的依赖关系——不可能只改动其中一个而不改动另外一个。如果问题出在依赖关系上，那么其表现就是重复设计。重复设计通常表现为逻辑上的重复设计——相同的表达式在代码的多个地方出现。利用各种对象可以很好地抽象出逻辑上的重复设计。
​	只有在编写下一个测试之前，消除现有的重复设计，通过一处且仅仅一处改动即可让下一个测试运行通过的可能性最大。

#### 伪实现和显明实现

​	伪实现：返回一个常量并主键用变量代替常量，直至伪实现代码成为真实实现的代码。一旦能使测试运行起来，常量会主键转换成用变量表示的表达式。伪实现可以很好的达到给自己测试通过的心里暗示和将专注点分离的范围控制作用。
​	显明实现：将真实的实现代码键入。
​	因为消除重复设计是第三步，我们前两步其实是可以不择手段地进行，伪实现是一种，还有复制其他对象代码的cv大法，但一定记得：在重复设计消除之前绝不回家。

#### 三角法

​	比如该书第二章这样的测试用例：

```java
	public void testEquality()
	{
		assertTrue(new Dollar(5).equals(new Dollar(5)));
	}
```

​	如果只有这么一个用例很难说程序是对的。不对的可能性有很多种，如Dollar使用一个假的equals实现，该函数直接返回true；又有可能Dollar的构造函数根本没有使用参数值而是一个内部常量；还有其它的很多种情况导致程序是错的。但是只要给该测试用例再加另一个方面的内容，结果就不一样了，基本上可以保持程序是对的。

​	一般也是在使用三角法后，将伪实现替换成显明实现。三角法可以很好的推动抽象。

```java
    public void testEquality()
	{
		assertTrue(new Dollar(5).equals(new Dollar(5)));
		assertFalse(new Dollar(5).equals(new Dollar(6)));
	}
```

#### 数值对象

​	一旦数值对象的实例变量值在构造函数中被指定，那么以后就不再也不允许发生变化。使用数值对象就不用担心别名问题：如果有一张5美元的支票，在各种方法传递计算后，不会变成其他数额。如果返回其他数额的支票肯定会是全新的对象，原来的对象数额不会变化。注意，使用数值对象时，必须要实现equals()函数，不然两个5美元的不同对象就不相等了，不符合原意。

#### 重构前补测试

​	当在重构的过程中，如果没有足够的测试程序，应当先补上支持该重构的测试程序。比如：在重构的过程中，一般化对象，向上抽取接口，添加新的实现类。

#### 测试不可运行状态

​	保守一点的做法是（分析原因后）将导致程序不能运行的改动恢复原貌，以使测试程序重新运行通过，然后修复代码问题（分析的原因），然后运行测试通过，再重试原来的改动。
​	或者：（分析原因后）回退更改，测试通过，新写一个能测出新更改带来的错误的测试，修正不正确的代码，测试通过。

#### 测试质量

​	测试使测试驱动开发自然而然的副产品，只要系统在运行，保持测试代码的运行就是相当有益的。当然，这些测试不能代替其他类型的测试，比如：性能测试，压力测试和可用性测试。
​	测试的衡量手段主要有一下几种：

- **行覆盖率**又称为语句覆盖率，指已经被执行到的语句占总可执行语句（不包含类似 C++ 的头文件声明、代码注释、空行等等）的百分比。这是最常用也是要求最低的覆盖率指标。
- **判定覆盖**又称分支覆盖，用以度量程序中每一个判定的分支是否都被测试到了，即代码中每个判断的取真分支和取假分支是否各被覆盖至少各一次。比如，对于 if(a>0 && b>0)，就要求覆盖“a>0 && b>0”为 TURE 和 FALSE 各一次。
- **条件覆盖**是指判定中的每个条件的可能取值至少满足一次，度量判定中的每个条件的结果 TRUE 和 FALSE 是否都被测试到了。比如，对于 if(a>0 && b>0)，就要求“a>0”取 TRUE 和 FALSE 各一次，同时要求“b>0”取 TRUE 和 FALSE 各一次。
- **缺陷插入**，改变一行代码的意思，测试应该不能通过。

​    对于测试的数量，用Phlip的话来说：“我们不是通过增加测试覆盖，使其覆盖输入的所有排列组合情况，而是让代码缩减，从而使用相同的测试就能覆盖到各种排列组合情况”

### 例2: xUnit Example

​	该例是使用Python，通过使用TDD来开发一种测试工具。

#### TDD开发步伐的大小

​	对于一些复杂的需求或者像对开发语言还不甚熟悉的情况，可以采用步幅较小的开发步幅。作者最初对于Python语言不熟悉，采用了较大的步伐，花费时间很久。但是对于一些熟悉的开发语言和常进行的操作，没有必要工作得这么细致。
​	但是，能够想要精通TDD，必须在需要时有能力小步前行。小步前行是一种能力。

#### 测试时创建的对象

​	创建用于测试的新对象的频繁程度，有这样两条互相矛盾的约束：

- 性能。为了让性能更好，几个测试中的相似对象，可以一次性创建出来，共同使用。
- 隔离。希望一个测试的成功与否与其他测试不相干。而共同使用相同对象，测试之间可能会相互影响。

​    大部分情况下，编写简单的测试比测试的执行性能更重要。

### 测试驱动开发的模式

#### 测试的重要性

​	测试的重要性可以用一张反馈图来表示：当压力越大，所作的测试就越少，测试越少，错误就越多，错误越多，压力就越大，如此循环往复。如何跳出这个循环？引入新的元素将现有的元素中一个替换掉：如果采用自动测试，每当感觉到压力时，就运行测试程序，可以给开发者一种良好的感觉，而且减少出错的次数，继而减小压力。

#### 相互独立的测试

​	首先，需要让测试程序尽可能的快，这样我们才有运行测试的冲动。但是，当系统具有一定的复杂度，测试也会越来越多，慢是不可避免的。所以需要在尽量小范围内进行测试，而不是对整个应用进行测试。所以必须使测试相互之间必须互不干扰，如果有n个测试失败了，那么就对应n个问题，不多不少。
​	所以必须努力**让问题分解为一些彼此正交的小问题**，使得为每个测试建立环境更加简单而快捷。如此，独立测试就鼓励根据高内聚，松耦合的对象组合出解决方案。

#### 断言优先

​	在写测试的时候，可以尝试先写断言，然后**根据断言一步一步向上推断出测试**。

- 从对最终系统的描述开始构建一个系统。
- 从最终代码能够通过的测试开始编写一个功能。
- 从断言开始编写一个测试。

#### 显然数据

​	让测试自身包含预期的和实际的结果，并且努力使它们之间的关系明显化。比如：

```java
bank.addRate("USD","GBP",STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
Money result = bank.convert(new Note(100,"USD"),"GBP");
assertEquals(new Note(49.25,"GBP"),result);
// 可以让上面的计算显得更明白一些
bank.addRate("USD","GBP",2);
bank.commission(0.015);
Money result = bank.convert(new Note(100,"USD"),"GBP");
assertEquals(new Note(100/2*(1-0.015),"GBP"),result);
```

#### 不可运行状态模式

​	下面这些模式是关于什么时候写测试，在哪里写测试，以及什么时候停止写测试的。

- 一步测试：如何从计划列表里面选择编写哪一个测试呢？选择哪个具有指导意义而且有把握实现的测试
- 开始测试：应该从哪个测试开始？从测试某个实质上不做任何工作的操作开始。如果一开始就编写一个真实的测试，会发现需要一同解决一连串的问题，比如这个操作隶属哪里，正确的输入输出。
- 说明测试：在团队中使用TDD测试的语言或者方式来给同时提供解释说明，以拓展自动测试。
- 学习测试：使用新工具或者新的API可以编写一些学习测试。
- 回归测试：当一个错误被发现时，先写一个尽可能小的会失败的测试，然后再修改代码使这个测试通过。
- 休息：也是极限编程XP中所提到的，强调休息的重要性。
- 重新开始：放弃一团糟的代码，重新开始。

#### 测试模式

- 模拟对象：如何测试一个依赖于昂贵且复杂的资源对象？创建一个这些资源的模拟版本。
- 自分流：测试对象间是否正常交互，可以让测试对象与测试用例而不是期望的对象进行交互。也就是说测试用例本身是一个对象，也可以作为一个模拟对象。自分流的优点是可读性高。
- 清扫测试死角：如何测试到不大可能被调用到的错误代码？使用一种特殊的对象调用它，让这个对象抛出一个异常而不做任何实际工作。比如想要测试文件系统满了后的异常处理，直接采用伪实现：继承File的自定义FullFile类，复写createNewFile()方法，直接抛出IOException。可以结合Java的匿名内部类。
- 不完整测试：在离开编程工作一段时间前，使剩下的测试不完整。这样当回到电脑时，看着半截的句子，才能够快速的接上头绪。

#### xUnit模式

- 断言：断言应该更加具体，比如：面积为50，而不是面积不为59。并且通常来说，测试等式期望值排在前面。
- 固定设施：像setUp()方法，可以创建几个测试中都需要的通用对象。tearDown()方法，释放外部资源。
- 测试异常：捕获每个期望的异常，然后会略他们，只有当没有抛出异常时才报错。

```java
// 测试正常情况
public void testRate() {
    exchange.addRate("USD","GBP",2);
    int rate = exchange.findRate("USD","GBP");
    assertEquals(2,rate);
}
// 测试异常情况
public void testMissingRate() {
    try{
        exchange.findRate("USD","GBP");
        fail();
    } catch (IllegalAragumentException excepted) {
        
    }
}
// 如果findRate没有抛出异常，就调用fail()，如果有非期望异常抛出就不会被捕获，也会抛出异常。总而言之，只有在抛出期望异常才会正常。
```

### 设计模式

​	模式的一个主要优点使尽管看起来我们一直在处理完全不同的问题，但我们处理的大多数问题是由我们所使用的工具产生的，而不是正在处理的外部问题产生的。

| 模式         | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| 命令         | 表示把计算作为一个对象而不是消息来调用，Java的Runnable接口。 |
| 值对象       | 通过创建其值一经创建便永不改变的对象来避免别名问题，对象的值不会在某个对象不知情的情况下被改变。 |
| 空对象       | 表示一种对象计算的基本情形，见代码1                          |
| 模板方法     | 使用可以通过继承来具体化的抽象方法来表示计算序列中不变的内容。计算中既有不变的顺序步骤，其具体的执行又是由子类实现其方法来进行的。 |
| 插入式对象   | 通过调用另一个具有两种或两种以上实现的对象来表示变化的对象，见代码2 |
| 插入式选择器 | 通过动态调用不同实例的不同方法来避免不必要的子类，见代码3    |
| 工厂方法     | 通过调用方法而不是构造函数来创建对象。尤其是Java中的构造函数缺乏清晰的表达性和灵活性。比如在资金例子中，需要的灵活性就是创建对象时，能够返回不同类的对象。 |
| 冒名顶替     | 通过引入现有协议的另一种实现来引入变化。空对象和递归组合就是冒名顶替的例子，这两种模式都使代码更简洁了，消除了重复。 |
| 递归组合     | 使用一个对象来表示一组对象的行为的组合，也就是该对象成为组成对象的冒名顶替者。见代码4 |
| 收集参数     | 来回传递一个用于汇集源于不同对象的计算结果的参数             |

代码1：空对象

```java
public boolean setReadOnly() {
    SecurityManger guard = System.getSecurityManger();
    if(guard != NULL) {
    	guard.canWrite(path);
    }
    return fileSystem.setReadOnly(this);
}
// 这里对空对象的处理可以改变，如下
// 先创建一个LaxSecurity的心类，它绝不会抛出异常
// LaxSecurity
public void canWrite(String path) {}
// 修改getSecurityManager()方法,没有可用的Manager就返回LaxManager
public static SecurityManager getSecurityManager() {
    return security == null ? new LaxSecurity():security;
}
// 现在调用者就不用检查空值了
public boolean setReadOnly() {
    SecurityManger security = System.getSecurityManager();
    security.canWrite(path);
    return fileSystem.setReadOnly(this);
}
```

代码2：插入式对象

```java
// 当第二次碰到有个条件判定时，就可以采用插入式对象
Figure selected;
public void mouseDown() {
    selected = findFigure();
    if(selected != null) 
        select(selected);
}
public void mouseMove() {
    if(selected!=null)
        move(selected);
    else
        moveSelectionRectangle();
}
public void mouseUp() {
    if(selected == null)
        selectAll();
}
// 这里每次使用selected时，都会去判定是否为null
// 这种重复判定需要去除掉
// 这里添加一个SelectionMode的插入式对象，该对象具有SingleSelection和MultipleSelection两种实现
SelectionMode mode;
public void mouseDown() {
    selected = findFigure();
    if(selected != null) 
        mode = SingleSelection(selected);
    else
        mode = MultipleSelection();
}
public void mouseMove() {
	mode.mouseMove();
}
public void mouseUp() {
    mode.mouseUp();
}
```

代码3：插入式选择器

```java
// 如果出现一个类中有10个子类并且每个子类仅仅实现一种方法的情况，就显得不合适
abstract class Report {
    abstract void print();
}
class HTMLReport extends Report {
    void print() {
        ...
    }
}
class XMLReport extends Report {
    void print() {
        ...
    }
}
// 可以使用switch语句，根据字段值不同，调用不同的方法
abstract class Report {
    String printMessage;
    
    Report(String printMessage) {
        this.printMessage = printMessage;
    }
    
    void print() {
        switch (printMessage) {
            case "printHTML":
                printHTML();
                break;
            case "printXML":
                printXML();
                break;
        }
    }
    
    void printHTML() {...}
    void printXML() {...}
}
// 下面是插入式选择器方案：
void pritn() {
    Method runMethod = getClass().getMethod(printMessage,null);
    runMethod.invoke(this,new Class[0]);
}
```

代码4：递归组合

```java
// Transaction
Transaction(Money value ) {
    this.value = value;
}
// Account计算余额
Transaction transavitons[];
Money balance() {
    Money sum = Money.zero();
    for( int i = 0; i<transactions.length; i++)
        sum = sum.plus(transcation[i].value);
    return sum;
}
// 但如果客户有多个账户想要查看所有余额呢？计算Account余额和计算所有Account余额不就出现了重复设计吗？该进行如下修改：

// Holding
interface Holding {
    Money balance();
}
// Transaction 
Money balance() {
    return value;
}
// Account：现在由Hoding组成，而Account本身也是Hoding
Holding holdings[];
Money balance() {
    Money sum = Money.zero();
    for(int i = 0; i<holdings.length; i++) 
        sum = sum.plus(hodings[i].balance());
    return sum;
}
```

### 重构

- 调和差异。统一两段看起来相似的代码：一点点地减少他们之间的差异，只有当它们完全一致时才去统一它们。比如清空子类，需要先使子类的方法与超类中的方法完全一致。然后一个接一个地清空子类，最后将指向他们的引用换成超类的。
- 隔离变化。改变具有多个部分的方法或对象的某一部分，首先需要对修改的部分进行隔离。比如如果发现findRate()只是返回一个实例变量，那么就考虑在用到这个方法的地方以内联的方式插入findRate()的代码，并删除这一方法。

#### 数据迁移

​	怎么从一种数据表示形式迁移至另外一种形式？临时制作冗余数据。

方式1：先改变内部表示形式，再改变外部的可见接口。

- 增加以新的数据格式表示的实例变量
- 再所有设置旧格式变量的地方设置新的格式变量
- 再任何使用旧格式变量的地方使用新的格式变量
- 删除原先的格式
- 改变外部接口以反映这种新的格式

方式2：先改变API

- 增加一个以新数据格式表示的参数
- 将新数据格式的参数转换成内部原先数据格式的表示
- 删除旧格式的参数
- 将使用旧格式的地方换成使用新格式
- 删除旧格式

#### 提取方法

​	比较复杂的原子级重构。但是它也是最常以自动化方式完成的重构，因此不必手工实现。

- 在方法中寻找一块可以单独独立出来形成方法的区域。循环体，整个循环以及条件语句分支都是常见的可供提取的部分。
- 保证在要提取的区域内不存在向在本区域外声明的临时变量赋值的语句。
- 将这部分代码从原来的方法中复制到新方法中
- 对于在新方法中用到的原方法中每个临时变量或者参数，都为新方法增加一个参数。
- 在原来的方法中调用新方法

#### 内联方法

​	简化变得过于繁琐或分散的控制流程，在调用方法的地方把方法本身内联起来。

#### 提取接口

​	声明接口->让现有类实现接口->向接口中添加必要方法->将类型声明从类改为接口。提取接口的实质就是：从一种实现转移到另一种实现。

#### 转移方法

- 复制方法，在目标类中粘贴方法并适当命名。
- 引用的原来对象->加一个参数来传递原来的对象。引用了原对象中的变量->变量变参数。如果原对象中的变量是设置好的，就不应该转移方法。
- 替换原方法调用成新方法

```java
// 在一个方法中，每当有超过一条以上的消息发送给另一个对象时，就可以考虑转移方法
// 比如如下的例子，有四条消息发送给bounds(它是一个Rectangle)
// Shape
int width = bounds.right() - bounds.left();
int height = bounds.bottom() - bounds.top();
int area = width * height;
// 可以转移方法
// Rectangle
public int area() {
    int width = this.right() - this.left();
    int height = this.bottom() - this.top();
    return width * height;
}
// Shape中
int area = bounds.area();
```

#### 方法对象

​	为了表示一个复杂的需要若干参数和局部变量的方法，可以为该方法创建一个对象。方法对象也可以解决提取方法时遇到的困难：比如一段代码有大量的临时变量和参数，每次提取其中的一段时，就必须随提取的方法提供5到6个临时变量和参数，会使得方法签名过长。而方法对象给了一个新的名字空间，可以提取方法而不用传递什么。

#### 方法中参数变为构造函数中的参数

​	如果同一个参数被传递给同一对象中的多个不同方法，那么可以只传递给构造函数来简化API。当然，如果某个实例变量只在一个方法中使用了，则反着重构。

- 在构造函数中添加参数，并添加实例变量，并在构造函数中设置变量
- 将parameter改为this.parameter
- 删除不必要参数
- 删除多余的"this."



